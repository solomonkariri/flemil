package org.flemil.ui.component;import java.util.Enumeration;import java.util.Vector;import javax.microedition.lcdui.Canvas;import javax.microedition.lcdui.Graphics;import org.flemil.control.GlobalControl;import org.flemil.control.Style;import org.flemil.ui.Container;import org.flemil.ui.Item;import org.flemil.ui.Scrollable;import org.flemil.ui.Window;import org.flemil.util.Rectangle;/** * Class that represents a collections of items that are treated as  * a group within the display if the application. A Panel * can have a number of properties that can be set by calling its methods. * Such properties include things such the layout of the items  * within the Panel and whether the Panel should allow its contents * to be scrolled horizontally or not. Panels can contain any collection of  * any items including other Panels, Lists and other basic Items   * @author Solomon Kariri */public class Panel implements Scrollable{      //Define the items alignment constants    public static final byte CENTER_VERTICAL_ALIGN=0x01;    public static final byte CENTER_HORIZONTAL_ALIGN=0x02;    public static final byte LEFT_HORIZONTAL_ALIGN=0x04;    public static final byte RIGHT_HORIZONTAL_ALIGN=0x08;    public static final byte SPAN_FULL_WIDTH=0x10;    //The parent to this item    private Item parent;    //The currently focussed item in this panel    private Item currentlyFocussed;    //Currently Added Items    private Vector children;    //The currently available display Rect    private Rectangle displayRect;    private ScrollBar verticalScrollBar;    //the variable for the right margin    private int rightMargin=0;    //the variable for the left margin    private int leftMargin=0;    //the variable for the top margin    private int topMargin=0;    //the variable for the left margin    private int bottomMargin=0;    private boolean vScrollable=true;     private int[] heightDistribution={100};            public int[] getHeightDistribution() {		return heightDistribution;	}	public void setHeightDistribution(int[] heightDistribution) {		this.heightDistribution = heightDistribution;	}	public int getRightMargin() {		return rightMargin;	}	public void setRightMargin(int rightMargin) {		this.rightMargin = rightMargin;	}	public int getLeftMargin() {		return leftMargin;	}	public void setLeftMargin(int leftMargin) {		this.leftMargin = leftMargin;	}	public int getTopMargin() {		return topMargin;	}	public void setTopMargin(int topMargin) {		this.topMargin = topMargin;	}	public int getBottomMargin() {		return bottomMargin;	}	public void setBottomMargin(int bottomMargin) {		this.bottomMargin = bottomMargin;	}    //variable for alignment    private int alignment=Panel.LEFT_HORIZONTAL_ALIGN;    //variables for keeping track of scrolling    private int currentYStart=1;    private boolean paintBorder;    private boolean focussed;    private boolean focusible=true;	private boolean vScrolling;	private int availableWidth=1;	private int availableHeight=1;	int scrWid;	private boolean focusAll;	private Item defaultFocusItem;	private boolean dragged;	private int lastPointY;	private Panel parentWindowPane;	private Item currentFocusible;	private Rectangle viewPortRect;    	public boolean isFocusible() {		if(!focusible)return false;		for(int i=0;i<children.size();i++){			if(((Item)children.elementAt(i)).isFocusible())return true;		}		if(focusAll)return true;		if(vScrollable && vScrolling){			return true;		}		return false;	}	public void setFocusible(boolean focusible) {		this.focusible = focusible;	}	public boolean isPaintBorder() {		return paintBorder;	}	public void setPaintBorder(boolean paintBorder) {		this.paintBorder = paintBorder;	}	/**     * Creates a new Panel with the specified parent Item     */    public Panel()    {        children=new Vector();        displayRect=new Rectangle();    }    /**     * Retuens the count of Items that has been added to this Panel. A Panel or     * List added to this Panel will be counted as s single Item. Items that      * contains a collection of other elements are also treated as such where     * the Item is counted as a single Item by its containing parent Item     * @return the number of Items that have been added to this Panel     */    public int getItemsCount()    {    	return children.size();    }    /**     * Sets whether this Panel should have all of its contained Items gain focus when      * it receives focus. This is handly when using Pnales with a collection of      * elements as List components where all the Items within the Panel will     * be required to gain focus     * @param focus true to focus on all Items on focus and false otherwise     */    public void setFocusAllOnFocus(boolean focus,Item defaultItem)    {    	focusAll=focus;     	if(focus)    	{    		focusible=true;    		defaultFocusItem=defaultItem;    	}    	if(focussed && focusAll)    	{    		focusAll();    		currentlyFocussed=defaultFocusItem;    	}    }    private void focusAll()    {		for(int i=0;i<children.size();i++)		{			if(((Item)children.elementAt(i)).isFocusible())			{				((Item)children.elementAt(i)).focusGained();			}		}    }    private void unFocusAll()    {		for(int i=0;i<children.size();i++)		{			if(((Item)children.elementAt(i)).isFocusible())			{				((Item)children.elementAt(i)).focusLost();			}		}    }    public Rectangle getDisplayRect()    {        return displayRect;    }    public void keyReleasedEventReturned(int keyCode)    {    }    public void keyReleasedEvent(int keyCode)    {    }    public void keyRepeatedEventReturned(int keyCode)    {    }    public void keyRepeatedEvent(int keyCode)    {        if(currentlyFocussed!=null)        {            currentlyFocussed.keyRepeatedEvent(keyCode);        }        else        {            //Process the key yourself        }    }    public void keyPressedEventReturned(int keyCode)    {    	int key=GlobalControl.getControl().getMainDisplayCanvas().getGameAction(keyCode);             switch(key)        {            case Canvas.DOWN:            {            	if(parentWindowPane==null)return;            	if(focusAll){            		parent.keyPressedEventReturned(keyCode);            		return;            	}            	if(currentlyFocussed!=null)            	{            		if(currentFocusible!=null &&             				children.indexOf(currentFocusible)>children.indexOf(currentlyFocussed)){            			currentlyFocussed=currentFocusible;            			currentFocusible.keyPressedEvent(keyCode);            			return;            		}            		Rectangle testRect=currentlyFocussed.getDisplayRect();            		Rectangle testRect2=viewPortRect;            		if(testRect.y+testRect.height>testRect2.y+testRect2.height-            				parentWindowPane.getBottomMargin()){            			scrollItems(-GlobalControl.getPanelScrollSpeed());            			if(currentFocusible!=null && currentFocusible.getDisplayRect().            					calculateIntersection(viewPortRect)==null)        				{        					currentFocusible.focusLost();        					currentFocusible=null;        				}            			return;            		}            		else{            			int index=children.indexOf(currentlyFocussed);            			if(index>=children.size()-1){            				if(parent!=null){            					parent.keyPressedEventReturned(keyCode);            					return;            				}            			}            			else{            				for(int i=index+1;i<children.size();i++){            					Item testItem=(Item)children.elementAt(i);            					Rectangle rct=testItem.getDisplayRect();            					if(rct.y+rct.height+1<=testRect2.y+testRect2.height-parentWindowPane.getBottomMargin()){            						index=i;            						if(testItem.isFocusible()){            							if(currentFocusible!=null)currentFocusible.focusLost();            							currentFocusible=testItem;            							currentlyFocussed=testItem;            							if(focussed)currentFocusible.focusGained();            							return;            						}            					}            					else{            						break;            					}            				}            				if(index==children.size()-1){            					if(parent!=null){            						parent.keyPressedEventReturned(keyCode);            					}            					return;            				}            				int maxScroll=GlobalControl.getControl().getDisplayArea().height/6;            				int currentHeights=0;            				Item selectedItem=(Item)children.elementAt(index+1);            				currentHeights+=selectedItem.getDisplayRect().height+1;            				index++;            				if(!selectedItem.isFocusible() && currentHeights<maxScroll){            					int i=index+1;                				for(;i<children.size();i++){                					Item testItem=(Item)children.elementAt(i);                					if(testItem.getDisplayRect().height+1+currentHeights<=maxScroll){                						currentHeights+=testItem.getDisplayRect().height+1;                						index++;                						if(testItem.isFocusible())break;                					}                				}            				}            				if(Math.abs(currentHeights)>maxScroll){            					currentHeights=maxScroll/2;            				}            				scrollItems(-currentHeights);            				selectedItem=(Item)children.elementAt(index);            				currentlyFocussed=selectedItem;            				if(selectedItem.isFocusible()){            					if(currentFocusible!=null)currentFocusible.focusLost();            					currentFocusible=selectedItem;            				}            				if(currentFocusible!=null && currentFocusible.getDisplayRect().            						calculateIntersection(viewPortRect)==null)            				{            					currentFocusible.focusLost();            					currentFocusible=null;            				}            				if(focussed && currentFocusible!=null){            					currentFocusible.focusGained();            				}            			}            		}            	}        		break;            }            case Canvas.UP:            {            	if(parentWindowPane==null)return;            	if(currentlyFocussed!=null)            	{            		if(currentFocusible!=null &&             				children.indexOf(currentFocusible)<children.indexOf(currentlyFocussed)){            			currentlyFocussed=currentFocusible;            			currentFocusible.keyPressedEvent(keyCode);            			return;            		}            		Rectangle testRect=currentlyFocussed.getDisplayRect();            		Rectangle testRect2=viewPortRect;            		if(testRect.y<testRect2.y+            				parentWindowPane.getTopMargin()){            			scrollItems(GlobalControl.getPanelScrollSpeed());            			if(currentFocusible!=null && currentFocusible.getDisplayRect().            					calculateIntersection(viewPortRect)==null)        				{        					currentFocusible.focusLost();        					currentFocusible=null;        				}            			return;            		}            		else{            			int index=children.indexOf(currentlyFocussed);            			if(index<=0){            				if(parent!=null){            					parent.keyPressedEventReturned(keyCode);            					return;            				}            			}            			else{            				for(int i=index-1;i>-1;i--){            					Item testItem=(Item)children.elementAt(i);            					Rectangle rct=testItem.getDisplayRect();            					if(rct.y-1>=testRect2.y+parentWindowPane.getTopMargin()){            						index=i;            						if(testItem.isFocusible()){            							if(currentFocusible!=null)currentFocusible.focusLost();            							currentFocusible=testItem;            							currentlyFocussed=testItem;            							if(focussed)currentFocusible.focusGained();            							return;            						}            					}            					else{            						break;            					}            				}            				if(index==0){            					if(parent!=null){            						parent.keyPressedEventReturned(keyCode);            					}            					return;            				}            				int maxScroll=GlobalControl.getControl().getDisplayArea().height/6;            				int currentHeights=0;            				Item selectedItem=(Item)children.elementAt(index-1);            				currentHeights+=selectedItem.getDisplayRect().height+1;            				index--;            				if(!selectedItem.isFocusible() && currentHeights<maxScroll){            					int i=index-1;                				for(;i>-1;i--){                					Item testItem=(Item)children.elementAt(i);                					if(testItem.getDisplayRect().height+1+currentHeights<=maxScroll){                						currentHeights+=testItem.getDisplayRect().height+1;                						index--;                						if(testItem.isFocusible())break;                					}                				}            				}            				if(Math.abs(currentHeights)>maxScroll){            					currentHeights=maxScroll/2;            				}            				scrollItems(currentHeights);            				selectedItem=(Item)children.elementAt(index);            				currentlyFocussed=selectedItem;            				if(selectedItem.isFocusible()){            					if(currentFocusible!=null)currentFocusible.focusLost();            					currentFocusible=selectedItem;            				}            				if(currentFocusible!=null && currentFocusible.getDisplayRect().            						calculateIntersection(viewPortRect)==null)            				{            					currentFocusible.focusLost();            					currentFocusible=null;            				}            				if(focussed && currentFocusible!=null){            					currentFocusible.focusGained();            				}            			}            		}            	}        		break;            }            case Canvas.LEFT:            {            	if(focusAll){            		parent.keyPressedEventReturned(keyCode);            		return;            	}            	parent.keyPressedEventReturned(keyCode);            	break;            }            case Canvas.RIGHT:            {            	if(focusAll){            		parent.keyPressedEventReturned(keyCode);            		return;            	}            	parent.keyPressedEventReturned(keyCode);            	break;            }            default:{            	if(parent!=null){            		parent.keyPressedEventReturned(keyCode);            	}            }        }    }    public void keyPressedEvent(int keyCode)    {    	if(currentlyFocussed!=null)    	{    		if(currentFocusible!=null){    			currentFocusible.keyPressedEvent(keyCode);    		}    		else{    			currentlyFocussed.keyPressedEvent(keyCode);    		}    	}    	else    	{    		if(parent!=null)    		{    			parent.keyPressedEventReturned(keyCode);    		}    	}    }    public void pointerPressedEventReturned(int x,int y)    {            }    public void pointerReleasedEventReturned(int x,int y)    {    	parent.pointerReleasedEventReturned(x, y);    }    public void pointerDraggedEventReturned(int x,int y)    {            }    public void pointerPressedEvent(int x,int y)    {    	dragged=false;    	if(vScrolling && verticalScrollBar!=null){    		if(verticalScrollBar.getDisplayRect().contains(x, y, 0)){    			verticalScrollBar.pointerPressedEvent(x, y);    		}    		else{    			lastPointY=y;        	}    	}    	else{    		for(int i=0;i<children.size();i++){        		Item testItem=(Item)children.elementAt(i);        		if(testItem.getDisplayRect().contains(x, y, 0)){        			testItem.pointerPressedEvent(x, y);        		}        	}    	}    }    public void pointerReleasedEvent(int x,int y)    {    	if(dragged)return;    	if(vScrolling && verticalScrollBar!=null){    		if(verticalScrollBar.getDisplayRect().contains(x, y, 0)){    			verticalScrollBar.pointerReleasedEvent(x, y);    			return;    		}    	}    	for(int i=0;i<children.size();i++){    		Item testItem=(Item)children.elementAt(i);    		if(testItem.getDisplayRect().contains(x, y, 0)){    			if(testItem.isFocusible() && !testItem.equals(currentFocusible)){    				currentlyFocussed.focusLost();    				if(currentFocusible!=null){    	    			currentFocusible.focusLost();    	    		}        			currentlyFocussed=testItem;        			if(currentlyFocussed.isFocusible()){        				currentFocusible=testItem;        				currentFocusible.focusGained();        			}    			}    			testItem.pointerReleasedEvent(x, y);    		}    	}    }    public void pointerDraggedEvent(int x,int y)    {    	if(!vScrolling){    		for(int i=0;i<children.size();i++){        		Item testItem=(Item)children.elementAt(i);        		if(testItem.getDisplayRect().contains(x, y, 0)){        			testItem.pointerDraggedEvent(x, y);        		}        	}    	}    	else{    		dragged=true;        	if(!verticalScrollBar.getDisplayRect().contains(x, y, 0)){        		int diff=y-lastPointY;            	lastPointY=y;            	if(vScrolling){            		scrollItems(diff);            	}        	}        	else{        		verticalScrollBar.pointerDraggedEvent(x, y);        	}    	}    }    public  void repaint(Rectangle clip)    {    	if(parent!=null)    	{    		parent.repaint(clip);    	}    }    public  void paint(Graphics g,Rectangle clip)    {    	Rectangle intersect=null;        if((intersect=this.displayRect.calculateIntersection(clip))!=null)        {        	g.setClip(intersect.x, intersect.y, intersect.width, intersect.height);        	if(focusAll && isFocussed())        	{        		g.setColor(((Integer)GlobalControl.getControl().getStyle().getProperty(            			Style.COMPONENT_FOCUS_BACKGROUND)).intValue());        		g.fillRect(intersect.x, intersect.y, intersect.width, intersect.height);        	}        	for(int i=0;i<children.size();i++)        	{        		Item tempChild=(Item)children.elementAt(i);        		tempChild.paint(g, intersect);        	}        	if(vScrolling && verticalScrollBar!=null)    		{    			verticalScrollBar.paint(g, intersect);    		}        	g.setClip(intersect.x, intersect.y, intersect.width, intersect.height);        	if(paintBorder)        	{        		g.setColor(focussed?((Integer)GlobalControl.getControl().getStyle().getProperty(            			Style.COMPONENT_FOCUS_OUTLINE_COLOR)).intValue():            				((Integer)GlobalControl.getControl().getStyle().getProperty(            			Style.COMPONENT_OUTLINE_COLOR)).intValue());        		int radius=((Integer)GlobalControl.getControl().getStyle().        				getProperty(Style.CURVES_RADIUS)).intValue();        		g.drawRoundRect(displayRect.x, displayRect.y,         				displayRect.width-1, displayRect.height-1,        				radius, radius);        	}        	g.setClip(clip.x, clip.y, clip.width, clip.height);        }    }    public Rectangle getMinimumDisplayRect(int availWidth)    {    	synchronized (this) {    		//Initialize the minimum possible width and height            int minWid=1;            int minHei=1;            availWidth-=(leftMargin+rightMargin);            //Get the number of children already added to this panel            int scrw=0;            if(vScrollable){            	scrw=availWidth/30;            }            for(int i=0;i<children.size();i++)            {                Rectangle minRect=(                        (Item)children.elementAt(i)).getMinimumDisplayRect(availWidth-scrw);                minWid=(minRect.width>minWid)?minRect.width:minWid;                minHei+=minRect.height;            }            Rectangle result=new Rectangle();            //Add 2 to width and height to account for border            result.width=availWidth;            result.height=minHei+topMargin+bottomMargin+children.size();            return result;		}    }    public void setDisplayRect(Rectangle rect)    {    	synchronized (this) {    		if(parentWindowPane == null)    			return;    		displayRect = rect;    		viewPortRect=new Rectangle(displayRect);    		viewPortRect.y+=topMargin;    		viewPortRect.height-=(topMargin+bottomMargin);    		Item test=parent;    		while(test!=null){    			if(test instanceof Window || test instanceof TabsControl){    				break;    			}    			else{    				if(test instanceof Panel && ((Panel)test).isVScrollable()){    					viewPortRect=((Panel)test).displayRect;    					viewPortRect.y+=((Panel)test).topMargin;    		    		viewPortRect.height-=(((Panel)test).topMargin+((Panel)test).bottomMargin);    				}    				test=test.getParent();    			}    		}    		layoutItems();    		if(currentlyFocussed != null && vScrolling){        		scrollRectToVisible(currentlyFocussed.getDisplayRect());        	}    	}    	if(focussed && currentlyFocussed!=null){    		currentlyFocussed.focusGained();    	}    	repaint(displayRect);    }            public void focusLost()    {    	focussed=false;    	if(!focusAll)    	{    		if(currentFocusible!=null)            {                currentFocusible.focusLost();            }    	}    	else    	{    		unFocusAll();    	}    	repaint(displayRect);    }    public void focusGained()    {        focussed = true;        if(children.isEmpty())            return;        if(!focusAll)        {            if(currentlyFocussed != null)                if(currentFocusible != null)                {                    currentFocusible.focusGained();                } else                {                    if(parentWindowPane == null)                        return;                    Rectangle rect1 = currentlyFocussed.getDisplayRect();                    Rectangle rect2 = viewPortRect;                    int diff = (rect2.y + rect2.height) - (rect1.y + rect1.height + 1);                    if(diff > 0)                    {                        int index = children.indexOf(currentlyFocussed);                        if(index < children.size() - 1)                        {                            for(int i = index + 1; i < children.size(); i++)                            {                                Item testItem = (Item)children.elementAt(i);                                if(testItem.getDisplayRect().y + testItem.getDisplayRect().height > rect2.y + rect2.height)                                    break;                                if(!testItem.isFocusible())                                    continue;                                currentFocusible = testItem;                                break;                            }                        }                    }                    if(currentFocusible != null)                    {                        currentFocusible.focusGained();                        currentlyFocussed = currentFocusible;                    }                }        } else        {            focusAll();            currentlyFocussed = defaultFocusItem;        }        if(currentFocusible!=null){        	currentFocusible.focusGained();        }        repaint(displayRect);    }        public void setParent(Item parent)    {        this.parent = parent;        parentWindowPane = null;        Item lastPanel = this;        if(parent != null)        {            Item test;            for(test = parent; test != null && !(test instanceof Window) && !(test instanceof TabsControl); test = test.getParent())                if(test instanceof Panel)                    lastPanel = test;            if(test != null)                parentWindowPane = (Panel)lastPanel;            if(verticalScrollBar != null)                verticalScrollBar.setParent(this);            try            {                for(int i = 0; i < children.size(); i++)                    ((Item)children.elementAt(i)).setParent(this);            }            catch(Exception e)            {//                e.printStackTrace();            }        } else        {            for(int i = 0; i < children.size(); i++)                ((Item)children.elementAt(i)).setParent(null);        }    }    public Item getParent()    {        return this.parent;    }    /**     * Returns the Item at the given index in this Panel.     * @param index the index for which to return the Item at     * @return Item at the index or null if the index value is not      * in the allowed values.     */    public Item getItem(int index)    {    	if(index>-1 && index<children.size())return (Item)children.elementAt(index);    	return null;    }    /**     * Adds an Item to the end of this Panel     * @param item the Item to be added to this Panel     */    public void add(Item item)    {    	children.addElement(item);    	if(item instanceof Panel && vScrollable){    		((Panel)item).setVScrollable(false);    	}    	synchronized (this) {            if(currentlyFocussed == null)            {                currentlyFocussed = item;                if(currentlyFocussed.isFocusible())                    currentFocusible = currentlyFocussed;            }            if(parent != null)                item.setParent(this);            if(parentWindowPane != null)                if(parentWindowPane.getParent() instanceof ScreenWindow)                    ((ScreenWindow)parentWindowPane.getParent()).setDisplayRect(parentWindowPane.getParent().getDisplayRect());                else                if(parentWindowPane.getParent() instanceof TabsControl)                    ((TabsControl)parentWindowPane.getParent()).refreshItemsRect(parentWindowPane);                else                if(parentWindowPane.getParent() instanceof PopUpWindow)                {                    ScreenWindow current = (ScreenWindow)parentWindowPane.getParent().getParent();                    if(current != null)                        current.layoutCurrentPopup();                }		}    	if(focussed && currentFocusible != null){            currentFocusible.focusGained();    	}    	if(parent!=null && displayRect.width>1){    		repaint(displayRect);    	}    }    /**     * Removes all the items that have been added to this Panel     */    public void removeAll()    {    	synchronized (this) {    		if(currentlyFocussed != null){    			currentlyFocussed.focusLost();    		}    		if(currentFocusible!=null){    			currentFocusible.focusLost();    		}            currentFocusible = null;            currentlyFocussed = null;            for(int i = 0; i < children.size(); i++)                ((Item)children.elementAt(i)).setParent(null);            children.removeAllElements();            layoutItems();		}    	if(parent!=null && displayRect.width>1){    		repaint(displayRect);    	}    }    /**     * Removes the Item passed to this method from this Panel     * @param item the Item to be removed from this Panel     */    public void remove(Item item)    {    	synchronized (this) {    		if(item.equals(currentFocusible))            {                if(focussed)                    currentFocusible.focusLost();                currentFocusible = null;            }            if(item.equals(currentlyFocussed))            {                currentlyFocussed = null;                int index = children.indexOf(item);                if(index > 0){                	currentlyFocussed = (Item)children.elementAt(index - 1);                }                else if(!children.isEmpty()){                	currentlyFocussed = (Item)children.elementAt(0);                }                if(currentFocusible==null && currentlyFocussed.isFocusible()){            		currentFocusible=currentlyFocussed;            		if(focussed){            			currentFocusible.focusGained();            		}            	}            }            children.removeElement(item);            item.setParent(null);            if(parent != null && parentWindowPane != null){                if(parentWindowPane.getParent() instanceof ScreenWindow){                    ((ScreenWindow)parentWindowPane.getParent()).setDisplayRect(parentWindowPane.getParent().getDisplayRect());                }                else if(parentWindowPane.getParent() instanceof TabsControl){                	((TabsControl)parentWindowPane.getParent()).refreshItemsRect(parentWindowPane);                }                else{                    GlobalControl.getControl().getCurrent().layoutCurrentPopup();                }            }            scrollRectToVisible(currentlyFocussed.getDisplayRect());		}    }    /**     * Remove the item at the given index from this Panel     * @param index the index at which to remove an Item     */    public void remove(int index)    {    	synchronized (this) {    		if(index < children.size() && index > -1){    			remove((Item)children.elementAt(index));    		}		}    }            private void layoutItems()    {    	synchronized (this) {    		if(vScrollable || (!vScrollable && heightDistribution.length<children.size())){    			if(children.isEmpty() || displayRect.width <= 1)                    return;                vScrolling = false;                verticalScrollBar = null;                scrWid = 0;                Vector tempStr = new Vector();                int trackY = getDisplayRect().y + topMargin;                for(int i = 0; i < children.size();)                {                    Item tempItem = (Item)children.elementAt(i);                    Rectangle tempRect = tempItem.getMinimumDisplayRect(displayRect.width - scrWid - leftMargin - rightMargin);                    tempRect.y = trackY;                    availableWidth = displayRect.width;                    if(tempRect.width > availableWidth - rightMargin - leftMargin)                        tempRect.width = availableWidth - rightMargin - leftMargin;                    if((alignment & 2) != 0)                        tempRect.x = ((displayRect.x - scrWid) + availableWidth / 2) - tempRect.width / 2;                    else                    if((alignment & 8) != 0)                        tempRect.x = (displayRect.x + availableWidth) - rightMargin - scrWid - tempRect.width;                    else                    if((alignment & 4) != 0)                        tempRect.x = displayRect.x + leftMargin;                    else                    if((alignment & Panel.SPAN_FULL_WIDTH) != 0)                    {                        tempRect.x = displayRect.x + leftMargin;                        tempRect.width = displayRect.width - rightMargin - leftMargin - scrWid;                    }                    if(tempRect.width > availableWidth)                        tempRect.width = availableWidth - scrWid;                    tempStr.addElement(tempRect);                    trackY += tempRect.height + 1;                    if(tempRect.y + tempRect.height > (displayRect.y + displayRect.height) && !vScrolling)                    {                        vScrolling = true;                        scrWid = displayRect.width / 30;                        i = 0;                        trackY = getDisplayRect().y + topMargin;                        tempStr.removeAllElements();                    } else                    {                        if(i == children.size() - 1)                            availableHeight = (tempRect.y + tempRect.height + topMargin + bottomMargin) - ((Rectangle)tempStr.elementAt(0)).y;                        i++;                    }                }                if(!children.isEmpty() && (alignment & 1) != 0)                {                    Rectangle tstRect = (Rectangle)tempStr.elementAt(children.size() - 1);                    if(tstRect.y + tstRect.height + bottomMargin < displayRect.y + displayRect.height)                    {                        int diff = ((displayRect.y + displayRect.height) - (tstRect.y + tstRect.height + bottomMargin)) / 2;                        for(int j = 0; j < children.size(); j++)                            ((Rectangle)tempStr.elementAt(j)).y += diff;                    }                }                for(int k = 0; k < children.size(); k++){                	((Item)children.elementAt(k)).setDisplayRect((Rectangle)tempStr.elementAt(k));                }                tempStr.removeAllElements();                layoutScrollers();    		}    		else if(children.size()==heightDistribution.length){    			    			int y=displayRect.y+topMargin;    			int availHeight=displayRect.height-topMargin-bottomMargin;    			for(int i=0;i<heightDistribution.length;i++){    				Item it=(Item) children.elementAt(i);    				Rectangle rct=new Rectangle(    						displayRect.x+leftMargin, y,     						displayRect.width-leftMargin-rightMargin,     						(heightDistribution[i]*availHeight)/100);    				it.getMinimumDisplayRect(rct.width);    				it.setDisplayRect(rct);    				y+=rct.height+1;    			}    		}		}        repaint(displayRect);    }            private void layoutScrollers()    {    	synchronized (this) {    		verticalScrollBar = null;            if(displayRect.width <= 1)                return;            currentYStart = displayRect.y + topMargin;            if(vScrolling)            {                int scrheight = displayRect.height;                verticalScrollBar = new ScrollBar(displayRect.height - (topMargin + bottomMargin), availableHeight);                if(parent != null)                    verticalScrollBar.setParent(this);                Rectangle rect = new Rectangle();                rect.x = (displayRect.x + displayRect.width) - scrWid;                rect.width = scrWid;                rect.y = displayRect.y;                rect.height = scrheight;                verticalScrollBar.setDisplayRect(rect);                verticalScrollBar.setCurrentPoint(0);            }		}    }            private void scrollItems(int dy)    {        if(dy != 0 && !vScrolling)        {            if(parentWindowPane == null)                return;            if(!parentWindowPane.equals(this))            {                parentWindowPane.scrollItems(dy);                dy = 0;            }        }        if(dy != 0 && vScrolling)        {            if(displayRect.y - (currentYStart + dy) > availableHeight - displayRect.height)                dy = displayRect.y - currentYStart - (availableHeight - displayRect.height);            if(currentYStart + dy > displayRect.y + topMargin)                dy = (displayRect.y + topMargin) - currentYStart;        }        if(displayRect.width > 1)        {            for(Enumeration elements = children.elements(); elements.hasMoreElements();)            {                Item tmpItem = (Item)elements.nextElement();                if(vScrolling)                    tmpItem.moveRect(0, dy);            }            if(vScrolling && verticalScrollBar != null)            {                currentYStart += dy;                verticalScrollBar.setCurrentPoint(-(currentYStart - (displayRect.y + topMargin)));            }        }        repaint(displayRect);    }    	/**	 * Sets the alignment to be used by this Panel to layout its Items. The value	 * of this parameter is a binary or (|) operation on the values	 * CENTER_VERTICAL_ALIGN ,CENTER_HORIZONTAL_ALIGN,	 * LEFT_HORIZONTAL_ALIGN,RIGHT_HORIZONTAL_ALIGN,	 * SPAN_FULL_WIDTH	 * The resultant layout is quite straightforward from the names of the constants.	 * for example passing the value CENTER_HORIZONTAL_ALIGN|CENTER_VERTICAL_ALIGN	 * centers the contents of this Panel both vertically and horizontally.	 * The values that determine the horizontal layout should be displayed	 * only once for example its not recommended to use a value such as	 * CENTER_HORIZONTAL_ALIGN|LEFT_HORIZONTAL_ALIGN will results in unpredictable	 * results. Only one of the directives will be taken into consideration 	 * @param alignment the alignmen to be used to display items in this Panel.	 */	public void setAlignment(int alignment) {		this.alignment = alignment;		layoutItems();	}	/**	 * Returns the alignment being currently used by this Panel to layout its Items	 * @return the alignment being currently used by this Panel	 */	int getAlignment() { 		return alignment;	}			public void scrollRectToVisible(Rectangle rect)	{		synchronized (this) {			if(!vScrolling && (parent instanceof Scrollable)){				((Scrollable)parent).scrollRectToVisible(rect);			}			else				if(vScrolling)				{					int diff = 0;					if(rect.y <= displayRect.y + topMargin)					{						diff = (displayRect.y + topMargin) - rect.y;						scrollItems(diff);					} 					else if(rect.y + rect.height > (displayRect.y + displayRect.height) - bottomMargin - 2)					{						diff = (rect.y + rect.height) - ((displayRect.y + displayRect.height) - bottomMargin - 2);						scrollItems(-diff);					}					if((parent instanceof Scrollable) && diff != 0 && ((Scrollable)parent).isVScrollable())					{						Rectangle tmp = new Rectangle(rect.x, rect.y, rect.width, rect.height);						tmp.y += diff;						((Scrollable)parent).scrollRectToVisible(tmp);					}				}		}	}        	public boolean isFocussed() {		return focussed;	}	public void moveRect(int dx, int dy) {		displayRect.x+=dx;		displayRect.y+=dy;		for(int i=0;i<children.size();i++){			((Item)children.elementAt(i)).moveRect(dx, dy);		}	}	public void scrollContentsVertically(int change) {		scrollItems(change);	}    public void itemHeightChanged(Item item, int change)    {    	synchronized (this) {    		int index = children.indexOf(item);            if(index != -1)            {                for(int i = index + 1; i < children.size(); i++)                    ((Item)children.elementAt(i)).moveRect(0, change);            }            if(parent == null || parentWindowPane == null)                return;            if((parent instanceof Container) && !vScrolling)            {                displayRect.height += change;                ((Container)parent).itemHeightChanged(this, change);            } else if(vScrolling)            {                Rectangle test = ((Item)children.elementAt(children.size() - 1)).getDisplayRect();                if(test.y + test.height < (displayRect.y + displayRect.height) - bottomMargin)                {                    if(parent != null && parentWindowPane != null)                        if(parentWindowPane.getParent() instanceof ScreenWindow)                            ((ScreenWindow)parentWindowPane.getParent()).setDisplayRect(parentWindowPane.getParent().getDisplayRect());                        else                        if(parentWindowPane.getParent() instanceof TabsControl)                            ((TabsControl)parentWindowPane.getParent()).refreshItemsRect(parentWindowPane);                        else                            GlobalControl.getControl().getCurrent().layoutCurrentPopup();                }                else{                	if(verticalScrollBar!=null && displayRect.width>1){                        availableHeight += change;                        int scrheight = displayRect.height;                        verticalScrollBar = new ScrollBar(displayRect.height - (topMargin + bottomMargin), availableHeight);                        if(parent != null)                            verticalScrollBar.setParent(this);                        Rectangle rect = new Rectangle();                        rect.x = (displayRect.x + displayRect.width) - scrWid;                        rect.width = scrWid;                        rect.y = displayRect.y;                        rect.height = scrheight;                        verticalScrollBar.setDisplayRect(rect);                        scrollRectToVisible(currentlyFocussed.getDisplayRect());                	}                }            }             else            {                Rectangle test = ((Item)children.elementAt(children.size() - 1)).getDisplayRect();                if(test.y + test.height > (displayRect.y + displayRect.height) - bottomMargin)                {                    if(parent != null && parentWindowPane != null)                        if(parentWindowPane.getParent() instanceof ScreenWindow)                            ((ScreenWindow)parentWindowPane.getParent()).setDisplayRect(parentWindowPane.getParent().getDisplayRect());                        else                        if(parentWindowPane.getParent() instanceof TabsControl)                            ((TabsControl)parentWindowPane.getParent()).refreshItemsRect(parentWindowPane);                        else                            GlobalControl.getControl().getCurrent().layoutCurrentPopup();                }            }		}    	repaint(displayRect);    }	public void setVScrollable(boolean vScrollable) {		this.vScrollable = vScrollable;	}	public boolean isVScrollable() {		return vScrollable;	}}